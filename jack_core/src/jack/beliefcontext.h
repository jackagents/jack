// Â© LUCAS FIELD AUTONOMOUS AGRICULTURE PTY LTD, ACN 607 923 133, 2025

#ifndef JACK_BELIEFCONTEXT_H
#define JACK_BELIEFCONTEXT_H

#include <jack/message.h>
#include <jack/messageschema.h>
#include <jack/handles.h>    // for AgentContext

#include <map>             // for map
#include <memory>          // for shared_ptr, static_pointer_cast
#include <utility>         // for pair
#include <vector>          // for vector
#include <string>          // for string, operator<

namespace aos::jack
{
class Resource;

/*! ***********************************************************************************************
 * @class   BeliefContext
 *
 * A container of belief sets representing a current context
 * ************************************************************************************************/
using Variant = std::any;

class BeliefContext
{
public:
    BeliefContext();

    /// @param other The BeliefContext to create a copy from
    BeliefContext(const BeliefContext &other);

    BeliefContext &operator=(BeliefContext &other) = delete;

    /// Create a deep copy clone of this BeliefContext
    /// @return A clone of this belief set
    BeliefContext *clone(JACK_CALL_SITE_ARGS_NO_TAIL_COMMA) const;

    /// @todo: Deprecate? Heap allocation cost, just use the const getter
    /// for the beliefset map?
    /// @return A list of the belief sets in the context
    std::vector<std::string> messageList() const;

    /// @return The beliefset matching the name, nullptr if not found
    std::shared_ptr<Message> message(const std::string& name) const;

    /// Add a message to the agent context
    void addMessage(std::shared_ptr<Message> msg);

    /// Add a resource to the context
    void addResource(Resource *resource);

    /// Add an action reply message to the context, these messages are checked
    /// first when querying values from the context.
    void addActionReplyMessage(std::shared_ptr<Message> msg);

    /// Flush all action reply messages from the context
    void flushActionReplyMessages() { m_actionReplyMessages.clear(); }

    /// @return Messages generated by actions executed using this context
    const std::vector<std::shared_ptr<Message>> &actionReplyMessages() const { return m_actionReplyMessages; }

    /// @return The resource handle matching the name, nullptr if not found
    std::shared_ptr<Resource> resource(std::string_view name) const;

    typedef std::map<std::string, std::shared_ptr<Message>, std::less<>> MessageMap;
    typedef std::map<std::string, std::shared_ptr<Resource>, std::less<>> ResourceMap;

    /// @return The list of resources in the context
    std::shared_ptr<ResourceMap> resources() { return m_resources; }

    /// @return The list of messages from the agent in the context
    std::shared_ptr<MessageMap> messages() { return m_messages; }

    /// @return The list of resources in the context
    const std::shared_ptr<ResourceMap> resources() const { return m_resources; }

    /// @return The list of messages from the agent in the context
    const std::shared_ptr<MessageMap> messages() const { return m_messages; }

    enum class SearchContext
    {
        ACTION_REPLY,
        GOAL,
        AGENT,
        COUNT,
    };

    struct SearchOrder
    {
        SearchContext order[static_cast<size_t>(SearchContext::COUNT)];
        size_t        size;
    };

    static constexpr inline SearchOrder SEARCH_DEFAULT           = {{SearchContext::ACTION_REPLY, SearchContext::GOAL, SearchContext::AGENT}, static_cast<size_t>(SearchContext::COUNT)};
    static constexpr inline SearchOrder SEARCH_ACTION_REPLY_ONLY = {{SearchContext::ACTION_REPLY}, /*size*/ 1 };
    static constexpr inline SearchOrder SEARCH_GOAL_ONLY         = {{SearchContext::GOAL},         /*size*/ 1 };
    static constexpr inline SearchOrder SEARCH_AGENT_ONLY        = {{SearchContext::AGENT},        /*size*/ 1 };

    class MessageQuery
    {
    public:
        MessageQuery() = default;
        MessageQuery(std::string_view name)       : m_name(name)      {}
        MessageQuery(const MessageSchema& schema) : m_schema(&schema) {}

        /// The schema to search a message for. If this field is set the `name`
        /// is ignored.
        const MessageSchema* m_schema = nullptr;

        /// Name of the message to query. This field is ignored if `schema` is
        /// set.
        std::string_view m_name;
    };

    /// Query a message from the context. The message will be searched for in
    /// the order specified in `search`. The default search order, `SEARCH_ALL`
    /// will look in order the action reply, goal and agent context
    /// respectively. respectively.
    ///
    /// @param message THe message to query
    /// @return True if the value was found in the context
    std::shared_ptr<Message> getMessage(const MessageQuery& query, const SearchOrder& search = SEARCH_DEFAULT) const;

    /// @copydoc Message::asPtr
    template <typename TypedMessage>
    std::shared_ptr<TypedMessage> getMessageAsPtr(const SearchOrder& search = SEARCH_DEFAULT) const;

    /// @return the goal message cast to the real message type
    template <typename TypedMessage>
    std::shared_ptr<TypedMessage> getGoalMessageAsPtr() const
    {
        return std::dynamic_pointer_cast<TypedMessage>(m_goal);
    }

    /// Query a belief in the context
    /// @param key The value to query
    /// @param bel The value to load the belief into if the belief exists under
    /// the 'key'.
    /// @return True if the value was found in the context
    template<class T>
    bool get(const std::string& key, T &bel, const SearchOrder& search = SEARCH_DEFAULT) const;

    /// Get a belief in the context
    /// @param key The value to query
    Variant get(const std::string& key, const SearchOrder& search = SEARCH_DEFAULT) const;

    const std::shared_ptr<Message>& goal() const { return m_goal; }

    void setGoalContext(const std::shared_ptr<Message>& goal) { m_goal = goal; }

    void setAgentContext(BeliefContext &context, const AgentHandle &agent);

    /// @return The owner of the agent context in this belief context. An empty
    /// handle if none applicable.
    const AgentHandle &agentContextOwner() const { return m_agent; }

    /// @param violatedResources (Optional) If there is a resource violation, violatedResource is set to the list of resources that are violated
    /// @return True if this context contains a resource that is being violated
    bool hasResourceViolation(std::vector<std::string> *violatedResources) const;

    // Lock a collection of resources
    // @param resources The list of resources to lock
    void lockResources(const std::vector<std::string> &resources);

    // Unlock a collection of resources
    // @param resources The list of resources to unlock
    void unlockResources(const std::vector<std::string> &resources);

    std::string toString() const;

    /// Print to standard out information about the belief context
    void print() const;

private:
    /// The handle of the agent that owns the agent context in this belief
    /// context, empty if none applicable.
    AgentHandle m_agent;

    /// Messages from the agent made available in the context
    std::shared_ptr<MessageMap> m_messages;

    /// Resources from the agent made available in the context
    std::shared_ptr<ResourceMap> m_resources;

    /// Goal message providing the parameters that the current goal was executed
    /// with.
    std::shared_ptr<Message> m_goal;

    /// List of messages returned by completing an action that are made
    /// available in the context for future actions.
    std::vector<std::shared_ptr<Message>> m_actionReplyMessages;
};

/*! ***********************************************************************************************
 * Template Implementations
 * ************************************************************************************************/
template <typename TypedMessage>
std::shared_ptr<TypedMessage> BeliefContext::getMessageAsPtr(const SearchOrder& search) const
{
    MessageQuery query  = MessageQuery(TypedMessage::MODEL_NAME);
    if (std::shared_ptr<Message> message = getMessage(query, search)) {
        return std::dynamic_pointer_cast<TypedMessage>(message);
    }
    return {};
}

template <class T>
bool BeliefContext::get(const std::string& key, T& bel, const SearchOrder& search) const
{
    ZoneScoped;
    for (size_t index = 0; index < search.size; index++) {
        SearchContext searchContext = search.order[index];
        switch (searchContext) {
            case SearchContext::ACTION_REPLY: {
                for (auto i = m_actionReplyMessages.rbegin(); i != m_actionReplyMessages.rend(); ++i) {

                    // cast

                    auto msg = (*i);
                    const T* value = msg->getConstPtr<T>(key);

                    if (value) {
                        bel = *value;
                        return true;
                    }
                }
            } break;

            case SearchContext::GOAL: {
                if (!m_goal) {
                    break;
                }

                const auto* ptr = m_goal->getPtr<T>(key);
                if (ptr) {
                    bel = *ptr;
                    return true;
                }
            } break;

            case SearchContext::AGENT: {
                for (const auto& kv : *m_messages) {
                    if (auto *ptr = kv.second->getPtr<T>(key)) {
                        bel = *ptr;
                        return true;
                    }
                }
            } break;

            case SearchContext::COUNT: {
            } break;
        }
    }

    return false;
}
} // namespace aos::jack

#endif
