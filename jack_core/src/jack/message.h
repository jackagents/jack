#pragma once

#include <jack/engine/uuid.h>  // for UniqueId
#include <jack/corelib.h>
#include <jack/utils.h>
#include <jack/fieldregistry.h>
#include <jack/event-protocol/protocol.h>

#include <map>            // for map
#include <utility>        // for pair
#include <string>         // for string, operator<<, operator<
#include <string_view>    // for string, operator<<, operator<
#include <any>            // for any, any_cast

/// Third Party
#include <nlohmann/json.hpp>

namespace aos::jack
{
class Engine;
class MessageSchema;

/******************************************************************************
 * @brief A generic representation to of a Message, use internally to JACK
 ******************************************************************************/
class Message
{
public:

    /**************************************************************************
     * Functions
     **************************************************************************/
    Message() = default;

    /// Set the value of a field in the message.
    ///
    /// Setting fields in a message requires that the field must pre-exist,
    /// either through instantiating from a MessageSchema, have having set
    /// fields before with create/overwrite SetFlags behvaviour.
    /// formally defined in the message schema.
    ///
    /// This function can return false in various circumstances depending on
    /// what SetFlags are set.
    ///
    /// 1. The passed in value's underlying type does not match the stored type,
    /// unless, overwrite is set.
    /// 2. The pre-existing field exists but the underlying value has not been
    /// set, unless overwrite is set.
    /// 3. The field does not exist, unless, create is set.
    ///
    /// @param[in] fieldName The name of the property to set
    /// @param[in] value The value of the property to set
    /// @return True if the value was set, false otherwise
    template<typename T>
    bool setFieldValue(const std::string& fieldName, const T& value);

    /// Get the value of the field from the message
    /// @param[in] field The field name to query from the message
    /// @return Value of the field, if it does not exist return a default
    /// initialised T
    template<typename T>
    T get(const std::string& fieldName) const;

    /// Get a pointer to the underlying value of the field from the message
    /// @param[in] field The field name to query from the message
    /// @return Pointer to the value of the field, null pointer if it does not
    /// exist
    template<typename T>
    const T* getConstPtr(const std::string& fieldName) const;

    /// Get a pointer to the underlying value of the field from the message
    /// @param[in] field The field name to query from the message
    /// @return Pointer to the value of the field, null pointer if it does not
    /// exist
    template<typename T>
    T* getPtr(const std::string& fieldName);

    /// Create a type-safe wrapper over the raw message using TypedMessage
    /// typically generated by jack-make. The created object holds a copy of
    /// the message it was created from.
    /// @tparam TypedMessage The derived message type
    /// @return std::unique_ptr to a copy of this message. If this message's schema does not match the
    /// TypedMessage's schema the pointer will be empty
    template<typename TypedMessage>
    std::unique_ptr<TypedMessage> asCopy() const
    {
        auto basePtr = this->clone();

        if (auto derivedPtr = dynamic_cast<TypedMessage*>(basePtr.get())) {
            basePtr.release(); //release ownership
            return std::unique_ptr<TypedMessage>(derivedPtr);
        } else {
            return {};
        }
    }

    /// Allow one message to be assigned to this one
    Message& operator=(const Message& other) {

        if (this != &other) {
            auto temp = other.clone();
            swap(*temp);
        }
        return *this;
    }

    /// Virtual Message Interface
    virtual void swap(Message& other) = 0;
    virtual std::unique_ptr<Message> clone() const = 0;

    virtual std::any getField(const std::string& fieldName) const = 0;
    virtual std::any getFieldPtr(const std::string& fieldName) const = 0;
    virtual bool setField(const std::string& fieldName, const std::any& value) = 0;

    virtual void serialise(nlohmann::json& j) const = 0;

    virtual std::string toString() const = 0;

    virtual bool operator==(const Message& other) const = 0;
    virtual bool operator!=(const Message& other) const = 0;
    
    const std::string& schema() const { return m_schemaName; }

    /// Set the reasoning message associated with this message
    void setReasoning(const std::string& text, int level);

    const std::string&               reasoningText () const { return m_reasoningText;  }
    int reasoningLevel() const { return m_reasoningLevel; }
    
protected:
    /// Name of the schema for this message
    std::string m_schemaName;
private:
    std::string m_reasoningText;
    // just using an int for now, should be protocol::BDILogLevel
    int m_reasoningLevel = 0;
};

template <typename T>
bool Message::setFieldValue(const std::string& fieldName, const T& value)
{
    /// \todo This uses the outdated, m_staticName which is incorrect. This is
    /// a globally shared registry instead of the per-engine registry.
    std::string_view fieldType = FieldFactory<T>::m_staticName;
    if (fieldType.empty()) {
        JACK_WARNING("Field type has not been registered to the Engine yet [fieldName={}, type={}]", fieldName, typeid(T).name());
        return false;
    }

    bool result = this->setField(fieldName, std::any(value));
    return result;
}

/// get a pointer to the field
template <class T>
const T* Message::getConstPtr(const std::string& fieldName) const
{
    const T* result = nullptr;
    std::any anyPtr = getFieldPtr(std::string(fieldName));

    if(!anyPtr.has_value()) {
        return result;
    }

    try {
        result = std::any_cast<const T*>(anyPtr);
    } catch (const std::bad_any_cast &e) {
        JACK_WARNING("Cannot get field, value stored at key is not desired type [field={}, desiredType={}, variantType={}, reason={}]",
                     fieldName,
                     typeid(T).name(),
                     anyPtr.type().name(),
                     e.what());
    }

    return result;
}

template <class T>
T* Message::getPtr(const std::string& fieldName)
{
    const auto* self = const_cast<const Message*>(this);
    T* result = const_cast<T*>(self->getConstPtr<T>(fieldName));
    return result;
}

template<typename T>
T Message::get(const std::string& field) const
{
    auto* ref = getConstPtr<T>(field);
    if (ref) {
        return *ref;
    } else {
        JACK_WARNING("Message does not contain requested field [field={}, msg={}]", field, toString());
    }

    /// The message doesn't contain this field
    /// How to handle the error?
    /// Log a error, throw exception?
    static T t = {};
    return t;
}

std::string format_as(const Message& message);

} // namespace aos::jack

