// Â© LUCAS FIELD AUTONOMOUS AGRICULTURE PTY LTD, ACN 607 923 133, 2025

#ifndef JACK_DAG_H
#define JACK_DAG_H

#include <jack/corelib.h>

#include <cstddef>     // for size_t
#include <type_traits> // for move
#include <vector>      // for vector, _Vector_iterator, _Vector_const_iterator

namespace aos { namespace jack {

class IntentionExecutor;
class Schedule;
struct SearchNode;

/*! ***********************************************************************************************
 * @class   DAGNode
 *
 * DAGNode represents a single node in our execution graph
 * ************************************************************************************************/

struct DAGNode {
    // The search node generated by the schedule. This pointer is owned by the schedule.
    SearchNode *node = nullptr;

    // List of direct dependant intentions that must be executed in parallel after this node is
    // completed
    std::vector<DAGNode*> children;

    // The current intention executing this node
    IntentionExecutor* intention = nullptr;
};

/*! ***********************************************************************************************
 * \class   IntentionExecutionDAG
 *
 * A dependency graph of all the intention that the agent intends to execute
 * This object is constructed from the current schedule, optimising for execution
 * ************************************************************************************************/

class IntentionExecutionDAG
{
public:
    /**************************************************************************
     * Constructors
     **************************************************************************/
    IntentionExecutionDAG() = default;

    IntentionExecutionDAG(const IntentionExecutionDAG &other) = delete;

    IntentionExecutionDAG& operator=(const IntentionExecutionDAG &other) = delete;

    /**************************************************************************
     * Functions
     **************************************************************************/
    /// @return True if the execution DAG is complete, i.e. when the open list
    /// is empty there are no more intentions to execute.
    bool done() const { return m_open.empty(); }

    /// @return A reference to the open list of this DAG
    const std::vector<DAGNode*>& open() const { return m_open; }

    /// @return A reference to all the nodes in the DAG
    const std::vector<DAGNode>& dagNodes() const { return m_dagNodes; }

    /// Generate a DAG from the given schedule. The DAG holds references into
    /// the schedule, hence the schedule must remain valid whilst the DAG is
    /// active. This function calls reset to ensure the DAG is valid for a new
    /// schedule.
    void setSchedule(Schedule *schedule);

    void reset() { m_open.clear(); m_dagNodes.clear(); }

    /// Close the given DAG Node marking it as complete
    /// @return A list of the next dependent nodes
    std::vector<DAGNode *> close(DAGNode *node);

    /**************************************************************************
     * Fields
     **************************************************************************/
protected:
    /// A list of the current open/valid intentions
    std::vector<DAGNode*> m_open;

    /// The backing storage of dag nodes for the open list
    std::vector<DAGNode> m_dagNodes;
};

}} // namespace aos::jack

#endif
